<?xml version="1.0" encoding="UTF-8"?>

<checkstyle-metadata>
  <module>
    <check name="DesignForExtensionCheck" fully-qualified-name="com.puppycrawl.tools.checkstyle.checks.design.DesignForExtensionCheck" parent="com.puppycrawl.tools.checkstyle.TreeWalker">
      <description><![CDATA[<p>
 Checks that classes are designed for extension (subclass creation).
 </p><p>
 Nothing wrong could be with founded classes.
 This check makes sense only for library projects (not application projects)
 which care of ideal OOP-design to make sure that class works in all cases even misusage.
 Even in library projects this check most likely will find classes that are designed for extension
 by somebody. User needs to use suppressions extensively to got a benefit from this check,
 and keep in suppressions all confirmed/known classes that are deigned for inheritance
 intentionally to let the check catch only new classes, and bring this to team/user attention.
 </p><p>
 ATTENTION: Only user can decide whether a class is designed for extension or not.
 The check just shows all classes which are possibly designed for extension.
 If smth inappropriate is found please use suppression.
 </p><p>
 ATTENTION: If the method which can be overridden in a subclass has a javadoc comment
 (a good practice is to explain its self-use of overridable methods) the check will not
 rise a violation. The violation can also be skipped if the method which can be overridden
 in a subclass has one or more annotations that are specified in ignoredAnnotations
 option. Note, that by default @Override annotation is not included in the
 ignoredAnnotations set as in a subclass the method which has the annotation can also be
 overridden in its subclass.
 </p><p>
 Problem is described at "Effective Java, 2nd Edition by Joshua Bloch" book, chapter
 "Item 17: Design and document for inheritance or else prohibit it".
 </p><p>
 Some quotes from book:
 </p><p>
 The check finds classes that have overridable methods (public or protected methods
 that are non-static, not-final, non-abstract) and have non-empty implementation.
 </p><p>
 Rationale: This library design style protects superclasses against being broken
 by subclasses. The downside is that subclasses are limited in their flexibility,
 in particular they cannot prevent execution of code in the superclass, but that
 also means that subclasses cannot corrupt the state of the superclass by forgetting
 to call the superclass's method.
 </p><p>
 More specifically, it enforces a programming style where superclasses provide
 empty "hooks" that can be implemented by subclasses.
 </p><p>
 Example of code that cause violation as it is designed for extension:
 </p><p>
 Example of code without violation:
 </p>]]></description>
      <properties>
        <property name="ignoredAnnotations" type="java.lang.String[]" default-value="After, AfterClass, Before, BeforeClass, Test">
          <description><![CDATA[Specify annotations which allow the check to
 skip the method from validation.]]></description>
        </property>
      </properties>
      <message-keys>
        <message-key key="design.forExtension"/>
      </message-keys>
    </check>
  </module>
</checkstyle-metadata>
